// src/lib/subscription-utils.ts
// ××¢×¨×›×ª ×× ×•×™×™× ××œ××” ×œ××™×™×˜×•×¨ - ××‘×•×¡×¡ ×¢×œ GitTor ×•××•×ª×× ×œ××‘× ×” MyTor

import { getSupabaseClient } from './api-auth';

// ===================================
// ğŸ·ï¸ Types & Interfaces
// ===================================
export interface SubscriptionLimits {
  businesses: number | 'unlimited';
  appointments_per_month: number | 'unlimited';
  sms_notifications: boolean;
  custom_branding: boolean;
  multi_therapist?: boolean;
  api_access?: boolean;
}

export interface SubscriptionPlan {
  tier: 'free' | 'premium' | 'business';
  name: string;
  price: number;
  limits: SubscriptionLimits;
  features: string[];
  stripe_price_id?: string;
}

export interface UserSubscription {
  id: string;
  user_id: string;
  email: string;
  subscribed: boolean;
  subscription_tier: 'free' | 'premium' | 'business';
  subscription_end?: string;
  monthly_limit: number;
  monthly_appointments_used: number;
  stripe_customer_id?: string;
  billing_period_start?: string;
  billing_period_end?: string;
  created_at?: string;
  updated_at?: string;
}

export interface LimitCheckResult {
  allowed: boolean;
  reason?: string;
  remainingCount?: number;
  upgradeRequired?: boolean;
}

// ===================================
// ğŸ“‹ ×ª×•×›× ×™×•×ª ×× ×•×™ - ×”×’×“×¨×•×ª ××œ××•×ª
// ===================================
export const SUBSCRIPTION_PLANS: Record<string, SubscriptionPlan> = {
  free: {
    tier: 'free',
    name: '×—×™× ×',
    price: 0,
    limits: {
      businesses: 1,
      appointments_per_month: 10,
      sms_notifications: false,
      custom_branding: false,
      multi_therapist: false,
      api_access: false
    },
    features: [
      '×¢×¡×§ ××—×“',
      '×¢×“ 10 ×ª×•×¨×™× ×‘×—×•×“×©',
      '×××©×§ ×‘×¡×™×¡×™',
      '×ª××™×›×” ×§×”×™×œ×ª×™×ª'
    ]
  },
  premium: {
    tier: 'premium',
    name: '×¤×¨×™××™×•×',
    price: 19.90,
    limits: {
      businesses: 3,
      appointments_per_month: 100,
      sms_notifications: true,
      custom_branding: true,
      multi_therapist: false,
      api_access: false
    },
    features: [
      '×¢×“ 3 ×¢×¡×§×™×',
      '×¢×“ 100 ×ª×•×¨×™× ×‘×—×•×“×©',
      'SMS ×”×ª×¨××•×ª',
      '×”×¡×¨×ª ××™×ª×•×’',
      '×“×•×—×•×ª ××ª×§×“××™×',
      '×ª××™×›×” ××•×¢×“×¤×ª'
    ]
  },
  business: {
    tier: 'business',
    name: '×¢×¡×§×™',
    price: 49.90,
    limits: {
      businesses: 'unlimited',
      appointments_per_month: 1000,
      sms_notifications: true,
      custom_branding: true,
      multi_therapist: true,
      api_access: true
    },
    features: [
      '×¢×¡×§×™× ×œ×œ× ×”×’×‘×œ×”',
      '×¢×“ 1000 ×ª×•×¨×™× ×‘×—×•×“×©',
      '××˜×¤×œ×™× ××¨×•×‘×™×',
      '×× ×œ×™×˜×™×§×” ××ª×§×“××ª',
      'API ×’×™×©×”',
      '×ª××™×›×” VIP'
    ]
  }
};

// ===================================
// ğŸ” ×¤×•× ×§×¦×™×•×ª ×§×‘×œ×ª × ×ª×•× ×™ ×× ×•×™
// ===================================

/**
 * ×§×‘×œ×ª ×¤×¨×˜×™ ×× ×•×™ ×©×œ ××©×ª××© ××”××¡×“
 */
export async function getUserSubscription(userId: string): Promise<UserSubscription> {
  const supabase = await getSupabaseClient('server');
  
  try {
    // ×—×™×¤×•×© ×‘××˜×‘×œ×ª subscribers
    const { data: subscriber, error } = await supabase
      .from('subscribers')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error && error.code !== 'PGRST116') {
      console.error('Error fetching subscription:', error);
    }

    // ×× ××™×Ÿ ×× ×•×™, ×”×—×–×¨ ×‘×¨×™×¨×ª ××—×“×œ
    if (!subscriber) {
      return {
        id: '',
        user_id: userId,
        email: '',
        subscribed: false,
        subscription_tier: 'free',
        monthly_limit: 10,
        monthly_appointments_used: 0,
        billing_period_start: new Date().toISOString().slice(0, 10),
        billing_period_end: new Date(new Date().setMonth(new Date().getMonth() + 1)).toISOString().slice(0, 10)
      };
    }

    return subscriber;
  } catch (error) {
    console.error('Error in getUserSubscription:', error);
    // ×‘×¨×™×¨×ª ××—×“×œ ×‘××§×¨×” ×©×œ ×©×’×™××”
    return {
      id: '',
      user_id: userId,
      email: '',
      subscribed: false,
      subscription_tier: 'free',
      monthly_limit: 10,
      monthly_appointments_used: 0
    };
  }
}

/**
 * ×§×‘×œ×ª ×ª×•×›× ×™×ª ×× ×•×™ ×œ×¤×™ tier
 */
export function getSubscriptionPlan(tier: 'free' | 'premium' | 'business'): SubscriptionPlan {
  return SUBSCRIPTION_PLANS[tier] || SUBSCRIPTION_PLANS.free;
}

/**
 * ×‘×“×™×§×” ×”×× ××©×ª××© ×”×•× premium (×›×œ ×× ×•×™ ×©××™× ×• ×—×™× ×)
 */
export async function isPremiumUser(userId: string): Promise<boolean> {
  const subscription = await getUserSubscription(userId);
  return subscription.subscription_tier !== 'free' && subscription.subscribed;
}

/**
 * ×‘×“×™×§×” ×”×× ××©×ª××© ×™×›×•×œ ×œ×’×©×ª ×œ×ª×›×•× ×” ××¡×•×™××ª
 */
export async function hasFeatureAccess(
  userId: string, 
  feature: keyof SubscriptionLimits
): Promise<boolean> {
  const subscription = await getUserSubscription(userId);
  const plan = SUBSCRIPTION_PLANS[subscription.subscription_tier];
  
  return !!plan.limits[feature];
}

// ===================================
// ğŸ”’ ×¤×•× ×§×¦×™×•×ª ×‘×“×™×§×ª ××’×‘×œ×•×ª
// ===================================

/**
 * ×‘×“×™×§×ª ××’×‘×œ×•×ª ××©×ª××© ×œ×¤×™ ×¤×¢×•×œ×” - ×”×¤×•× ×§×¦×™×” ×”××¨×›×–×™×ª
 */
export async function checkUserLimit(
  userId: string, 
  action: 'create_business' | 'create_appointment' | 'send_sms'
): Promise<LimitCheckResult> {
  try {
    const subscription = await getUserSubscription(userId);
    const plan = SUBSCRIPTION_PLANS[subscription.subscription_tier];

    switch (action) {
      case 'create_business':
        return await checkBusinessLimit(userId, plan);
      
      case 'create_appointment':
        return await checkAppointmentLimit(subscription, plan);
      
      case 'send_sms':
        return await checkSMSLimit(plan);
      
      default:
        return { allowed: true };
    }
  } catch (error) {
    console.error('Error in checkUserLimit:', error);
    return { 
      allowed: false, 
      reason: '×©×’×™××” ×‘×‘×“×™×§×ª ××’×‘×œ×•×ª. × ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.',
      upgradeRequired: false
    };
  }
}

/**
 * ×‘×“×™×§×ª ××’×‘×œ×ª ×¢×¡×§×™×
 */
async function checkBusinessLimit(userId: string, plan: SubscriptionPlan): Promise<LimitCheckResult> {
  if (plan.limits.businesses === 'unlimited') {
    return { allowed: true };
  }
  
  const businessCount = await getBusinessCount(userId);
  const maxBusinesses = plan.limits.businesses as number;
  const remaining = maxBusinesses - businessCount;
  
  if (businessCount >= maxBusinesses) {
    return { 
      allowed: false, 
      reason: `×”×’×¢×ª ×œ××’×‘×œ×ª ×”×¢×¡×§×™× (${maxBusinesses}). ×©×“×¨×’ ×œ×ª×•×›× ×™×ª ×’×‘×•×”×” ×™×•×ª×¨ ×œ×¢×¡×§×™× × ×•×¡×¤×™×.`,
      remainingCount: 0,
      upgradeRequired: true
    };
  }
  
  return { 
    allowed: true, 
    remainingCount: remaining 
  };
}

/**
 * ×‘×“×™×§×ª ××’×‘×œ×ª ×ª×•×¨×™× ×—×•×“×©×™×ª
 */
async function checkAppointmentLimit(subscription: UserSubscription, plan: SubscriptionPlan): Promise<LimitCheckResult> {
  if (plan.limits.appointments_per_month === 'unlimited') {
    return { allowed: true };
  }
  
  // ×‘×“×™×§×” ×”×× ×× ×—× ×• ×‘×ª×§×•×¤×ª ×”×—×™×•×‘ ×”× ×•×›×—×ª
  const now = new Date();
  const billingEnd = subscription.billing_period_end ? new Date(subscription.billing_period_end) : null;
  
  // ×× ×¢×‘×¨× ×• ××ª ×ª×§×•×¤×ª ×”×—×™×•×‘, ××™×¤×•×¡ ×”×©×™××•×©
  if (billingEnd && now > billingEnd) {
    await resetMonthlyUsage(subscription.user_id);
    // ×”×—×–×¨ ×× ×•×™ ××¢×•×“×›×Ÿ
    const updatedSubscription = await getUserSubscription(subscription.user_id);
    subscription.monthly_appointments_used = updatedSubscription.monthly_appointments_used;
  }
  
  const appointmentCount = subscription.monthly_appointments_used || 0;
  const monthlyLimit = subscription.monthly_limit;
  const remaining = monthlyLimit - appointmentCount;
  
  if (appointmentCount >= monthlyLimit) {
    return { 
      allowed: false, 
      reason: `×”×’×¢×ª ×œ××’×‘×œ×ª ×”×ª×•×¨×™× ×”×—×•×“×©×™×ª (${monthlyLimit}). ×©×“×¨×’ ×œ×ª×•×›× ×™×ª ×’×‘×•×”×” ×™×•×ª×¨ ×œ×ª×•×¨×™× × ×•×¡×¤×™×.`,
      remainingCount: 0,
      upgradeRequired: true
    };
  }
  
  return { 
    allowed: true, 
    remainingCount: remaining 
  };
}

/**
 * ×‘×“×™×§×ª ××’×‘×œ×ª SMS
 */
async function checkSMSLimit(plan: SubscriptionPlan): Promise<LimitCheckResult> {
  if (!plan.limits.sms_notifications) {
    return { 
      allowed: false, 
      reason: 'SMS ×”×ª×¨××•×ª ×–××™× ×•×ª ×¨×§ ×‘×ª×•×›× ×™×•×ª ×‘×ª×©×œ×•×. ×©×“×¨×’ ×›×“×™ ×œ×§×‘×œ ×”×ª×¨××•×ª SMS ××•×˜×•××˜×™×•×ª.',
      upgradeRequired: true
    };
  }
  return { allowed: true };
}

// ===================================
// ğŸ“Š ×¤×•× ×§×¦×™×•×ª ×¢×“×›×•×Ÿ ×©×™××•×©
// ===================================

/**
 * ×¢×“×›×•×Ÿ ×©×™××•×© ×‘×ª×•×¨×™× (×œ×”×¤×¢×™×œ ××—×¨×™ ×™×¦×™×¨×ª ×ª×•×¨)
 */
export async function incrementAppointmentUsage(userId: string): Promise<void> {
  const supabase = await getSupabaseClient('server');
  
  try {
    // ×¢×“×›×•×Ÿ ×‘×˜×‘×œ×ª subscribers
    const { error } = await supabase
      .from('subscribers')
      .update({ 
        monthly_appointments_used: supabase.rpc('increment_appointment_usage', { user_id_param: userId })
      })
      .eq('user_id', userId);

    if (error) {
      console.error('Error incrementing appointment usage:', error);
      
      // ×× RPC ×œ× ×¢×•×‘×“, × ×¡×” ×¢×“×›×•×Ÿ ×™×©×™×¨
      const subscription = await getUserSubscription(userId);
      await supabase
        .from('subscribers')
        .update({ 
          monthly_appointments_used: (subscription.monthly_appointments_used || 0) + 1,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', userId);
    }
  } catch (error) {
    console.error('Error in incrementAppointmentUsage:', error);
  }
}

/**
 * ××™×¤×•×¡ ×©×™××•×© ×—×•×“×©×™ (×œ×§×¨×•×Ÿ job ××• ×›×©×¢×•×‘×¨ ×—×•×“×©)
 */
export async function resetMonthlyUsage(userId?: string): Promise<void> {
  const supabase = await getSupabaseClient('server');
  
  try {
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    const currentPeriodStart = new Date(now.getFullYear(), now.getMonth(), 1);
    
    let query = supabase
      .from('subscribers')
      .update({ 
        monthly_appointments_used: 0,
        billing_period_start: currentPeriodStart.toISOString().slice(0, 10),
        billing_period_end: nextMonth.toISOString().slice(0, 10),
        updated_at: new Date().toISOString()
      });

    if (userId) {
      // ××™×¤×•×¡ ×œ××©×ª××© ×¡×¤×¦×™×¤×™
      query = query.eq('user_id', userId);
    } else {
      // ××™×¤×•×¡ ×œ×›×œ ×”××©×ª××©×™× ×©×¡×™×™××• ××ª ×”×ª×§×•×¤×” ×”×—×•×“×©×™×ª
      query = query.lte('billing_period_end', now.toISOString().slice(0, 10));
    }

    const { error } = await query;

    if (error) {
      console.error('Error resetting monthly usage:', error);
    } else {
      console.log(`Monthly usage reset ${userId ? `for user ${userId}` : 'for all eligible users'}`);
    }
  } catch (error) {
    console.error('Error in resetMonthlyUsage:', error);
  }
}

// ===================================
// ğŸ’¾ ×¤×•× ×§×¦×™×•×ª × ×™×”×•×œ ×× ×•×™×™×
// ===================================

/**
 * ×™×¦×™×¨×ª ××• ×¢×“×›×•×Ÿ ×× ×•×™ ×‘××¡×“ ×”× ×ª×•× ×™×
 */
export async function upsertSubscriber(data: {
  userId: string;
  email: string;
  stripeCustomerId?: string;
  subscribed: boolean;
  subscriptionTier: 'free' | 'premium' | 'business';
  subscriptionEnd?: string;
  monthlyLimit?: number;
}): Promise<void> {
  const supabase = await getSupabaseClient('server');
  
  try {
    const plan = SUBSCRIPTION_PLANS[data.subscriptionTier];
    const monthlyLimit = data.monthlyLimit || 
      (typeof plan.limits.appointments_per_month === 'number' ? plan.limits.appointments_per_month : 10);
    
    // ×¢×“×›×•×Ÿ/×™×¦×™×¨×” ×‘×˜×‘×œ×ª subscribers
    const { error: subscriberError } = await supabase
      .from('subscribers')
      .upsert({
        user_id: data.userId,
        email: data.email,
        stripe_customer_id: data.stripeCustomerId,
        subscribed: data.subscribed,
        subscription_tier: data.subscriptionTier,
        subscription_end: data.subscriptionEnd,
        monthly_limit: monthlyLimit,
        updated_at: new Date().toISOString()
      }, { 
        onConflict: 'user_id' 
      });

    if (subscriberError) {
      console.error('Error upserting subscriber:', subscriberError);
      throw subscriberError;
    }

    // ×¢×“×›×•×Ÿ ×’× ×‘×˜×‘×œ×ª users
    const { error: userError } = await supabase
      .from('users')
      .update({ subscription_tier: data.subscriptionTier })
      .eq('id', data.userId);

    if (userError) {
      console.error('Error updating user subscription tier:', userError);
    }

    console.log(`Subscription updated for user ${data.userId}: ${data.subscriptionTier}`);
  } catch (error) {
    console.error('Error in upsertSubscriber:', error);
    throw error;
  }
}

/**
 * ×‘×™×˜×•×œ ×× ×•×™ - ×”×—×–×¨×” ×œ×—×™× ×
 */
export async function cancelSubscription(userId: string): Promise<void> {
  await upsertSubscriber({
    userId,
    email: '', // ×™×•×¢×“×›×Ÿ ×‘×¤×•×¢×œ ××”××¡×“
    subscribed: false,
    subscriptionTier: 'free',
    monthlyLimit: 10
  });
}

// ===================================
// ğŸ”§ ×¤×•× ×§×¦×™×•×ª ×¢×–×¨
// ===================================

/**
 * ×¡×¤×™×¨×ª ×¢×¡×§×™× ×¤×¢×™×œ×™× ×©×œ ××©×ª××©
 */
async function getBusinessCount(userId: string): Promise<number> {
  const supabase = await getSupabaseClient('server');
  
  try {
    const { count, error } = await supabase
      .from('businesses')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('is_active', true);

    if (error) {
      console.error('Error counting businesses:', error);
      return 0;
    }

    return count || 0;
  } catch (error) {
    console.error('Error in getBusinessCount:', error);
    return 0;
  }
}

/**
 * ×¡×¤×™×¨×ª ×ª×•×¨×™× ×‘××—×¦×™×ª ×”× ×•×›×—×ª
 */
export async function getMonthlyAppointmentCount(userId: string): Promise<number> {
  const subscription = await getUserSubscription(userId);
  return subscription.monthly_appointments_used || 0;
}

/**
 * ×§×‘×œ×ª ×¡×˜×˜×™×¡×˜×™×§×•×ª ×©×™××•×©
 */
export async function getUsageStats(userId: string): Promise<{
  businessCount: number;
  monthlyAppointments: number;
  monthlyLimit: number;
  usagePercentage: number;
  tier: string;
}> {
  const [subscription, businessCount] = await Promise.all([
    getUserSubscription(userId),
    getBusinessCount(userId)
  ]);

  const usagePercentage = subscription.monthly_limit > 0 
    ? (subscription.monthly_appointments_used / subscription.monthly_limit) * 100 
    : 0;

  return {
    businessCount,
    monthlyAppointments: subscription.monthly_appointments_used,
    monthlyLimit: subscription.monthly_limit,
    usagePercentage: Math.round(usagePercentage),
    tier: subscription.subscription_tier
  };
}

/**
 * ×‘×“×™×§×” ×”×× ×”××©×ª××© ×¦×¨×™×š ×œ×”×–×”×™×¨ ×¢×œ ××’×‘×œ×”
 */
export async function shouldShowUsageWarning(userId: string, threshold: number = 80): Promise<{
  shouldShow: boolean;
  type: 'businesses' | 'appointments' | null;
  message?: string;
}> {
  const stats = await getUsageStats(userId);
  
  // ×‘×“×™×§×ª ××’×‘×œ×ª ×¢×¡×§×™×
  const plan = SUBSCRIPTION_PLANS[stats.tier];
  if (plan.limits.businesses !== 'unlimited') {
    const businessLimit = plan.limits.businesses as number;
    const businessUsagePercent = (stats.businessCount / businessLimit) * 100;
    
    if (businessUsagePercent >= threshold) {
      return {
        shouldShow: true,
        type: 'businesses',
        message: `××ª×” ××©×ª××© ×‘-${stats.businessCount} ××ª×•×š ${businessLimit} ×¢×¡×§×™×`
      };
    }
  }
  
  // ×‘×“×™×§×ª ××’×‘×œ×ª ×ª×•×¨×™×
  if (stats.usagePercentage >= threshold) {
    return {
      shouldShow: true,
      type: 'appointments',
      message: `×”×©×ª××©×ª ×‘-${stats.monthlyAppointments} ××ª×•×š ${stats.monthlyLimit} ×ª×•×¨×™× ×”×—×•×“×©`
    };
  }
  
  return { shouldShow: false, type: null };
}

// ===================================
// ğŸ¯ ×¤×•× ×§×¦×™×•×ª ×××¦×¢×™×
// ===================================

/**
 * ×¤×•× ×§×¦×™×” ×œ×•×™×™×“×¦×™×” ×©×œ ××’×‘×œ×•×ª ×œ×¤× ×™ ×¤×¢×•×œ×”
 */
export async function validateAndExecute<T>(
  userId: string,
  action: 'create_business' | 'create_appointment' | 'send_sms',
  executor: () => Promise<T>
): Promise<T> {
  const limitCheck = await checkUserLimit(userId, action);
  
  if (!limitCheck.allowed) {
    throw new Error(limitCheck.reason || '×”×’×¢×ª ×œ××’×‘×œ×”');
  }
  
  const result = await executor();
  
  // ×¢×“×›×•×Ÿ ×©×™××•×© ××—×¨×™ ×”×¤×¢×•×œ×”
  if (action === 'create_appointment') {
    await incrementAppointmentUsage(userId);
  }
  
  return result;
}

/**
 * ×™×¦×™×¨×ª ××™×“×¢ ×¢×œ ×ª×•×›× ×™×ª ×”××•××œ×¦×ª ×œ×©×“×¨×•×’
 */
export function getRecommendedUpgrade(currentTier: 'free' | 'premium' | 'business'): SubscriptionPlan | null {
  switch (currentTier) {
    case 'free':
      return SUBSCRIPTION_PLANS.premium;
    case 'premium':
      return SUBSCRIPTION_PLANS.business;
    case 'business':
      return null; // ×›×‘×¨ ×‘×ª×•×›× ×™×ª ×”×’×‘×•×”×” ×‘×™×•×ª×¨
    default:
      return SUBSCRIPTION_PLANS.premium;
  }
}

// ===================================
// ğŸ“± ×¤×•× ×§×¦×™×•×ª ×œRPC ×‘××¡×“ ×”× ×ª×•× ×™×
// ===================================

/**
 * ×™×¦×™×¨×ª ×¤×•× ×§×¦×™×” RPC ×‘××¡×“ ×”× ×ª×•× ×™× ×œ×¢×“×›×•×Ÿ ×©×™××•×© (×œ×”×¨×¦×” ×¤×¢× ××—×ª)
 */
export const createIncrementUsageFunction = `
CREATE OR REPLACE FUNCTION increment_appointment_usage(user_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
    new_count INTEGER;
BEGIN
    UPDATE subscribers 
    SET monthly_appointments_used = monthly_appointments_used + 1,
        updated_at = NOW()
    WHERE user_id = user_id_param
    RETURNING monthly_appointments_used INTO new_count;
    
    RETURN COALESCE(new_count, 0);
END;
$$ LANGUAGE plpgsql;
`;

/**
 * ×¤×•× ×§×¦×™×” ×œ××™×¤×•×¡ ×©×™××•×© ×—×•×“×©×™ ×‘DB
 */
export const createResetUsageFunction = `
CREATE OR REPLACE FUNCTION reset_monthly_usage()
RETURNS INTEGER AS $$
DECLARE
    reset_count INTEGER;
BEGIN
    UPDATE subscribers 
    SET monthly_appointments_used = 0,
        billing_period_start = date_trunc('month', NOW()),
        billing_period_end = date_trunc('month', NOW()) + INTERVAL '1 month',
        updated_at = NOW()
    WHERE billing_period_end <= NOW()::date;
    
    GET DIAGNOSTICS reset_count = ROW_COUNT;
    RETURN reset_count;
END;
$$ LANGUAGE plpgsql;
`;

// ===================================
// ğŸ“¤ Export all functions
// ===================================
export default {
  // Core functions
  getUserSubscription,
  checkUserLimit,
  incrementAppointmentUsage,
  resetMonthlyUsage,
  upsertSubscriber,
  
  // Helper functions
  isPremiumUser,
  hasFeatureAccess,
  getUsageStats,
  shouldShowUsageWarning,
  getRecommendedUpgrade,
  validateAndExecute,
  
  // Constants
  SUBSCRIPTION_PLANS
};