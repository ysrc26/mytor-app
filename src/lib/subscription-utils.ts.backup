// src/lib/subscription-utils.ts
// מערכת מנויים מלאה למייטור - מבוסס על GitTor ומותאם למבנה MyTor

import { getSupabaseClient } from './api-auth';

// ===================================
// 🏷️ Types & Interfaces
// ===================================
export interface SubscriptionLimits {
  businesses: number | 'unlimited';
  appointments_per_month: number | 'unlimited';
  sms_notifications: boolean;
  custom_branding: boolean;
  multi_therapist?: boolean;
  api_access?: boolean;
}

export interface SubscriptionPlan {
  tier: 'free' | 'premium' | 'business';
  name: string;
  price: number;
  limits: SubscriptionLimits;
  features: string[];
  stripe_price_id?: string;
}

export interface UserSubscription {
  id: string;
  user_id: string;
  email: string;
  subscribed: boolean;
  subscription_tier: 'free' | 'premium' | 'business';
  subscription_end?: string;
  monthly_limit: number;
  monthly_appointments_used: number;
  stripe_customer_id?: string;
  billing_period_start?: string;
  billing_period_end?: string;
  created_at?: string;
  updated_at?: string;
}

export interface LimitCheckResult {
  allowed: boolean;
  reason?: string;
  remainingCount?: number;
  upgradeRequired?: boolean;
}

// ===================================
// 📋 תוכניות מנוי - הגדרות מלאות
// ===================================
export const SUBSCRIPTION_PLANS: Record<string, SubscriptionPlan> = {
  free: {
    tier: 'free',
    name: 'חינם',
    price: 0,
    limits: {
      businesses: 1,
      appointments_per_month: 10,
      sms_notifications: false,
      custom_branding: false,
      multi_therapist: false,
      api_access: false
    },
    features: [
      'עסק אחד',
      'עד 10 תורים בחודש',
      'ממשק בסיסי',
      'תמיכה קהילתית'
    ]
  },
  premium: {
    tier: 'premium',
    name: 'פרימיום',
    price: 19.90,
    limits: {
      businesses: 3,
      appointments_per_month: 100,
      sms_notifications: true,
      custom_branding: true,
      multi_therapist: false,
      api_access: false
    },
    features: [
      'עד 3 עסקים',
      'עד 100 תורים בחודש',
      'SMS התראות',
      'הסרת מיתוג',
      'דוחות מתקדמים',
      'תמיכה מועדפת'
    ]
  },
  business: {
    tier: 'business',
    name: 'עסקי',
    price: 49.90,
    limits: {
      businesses: 'unlimited',
      appointments_per_month: 1000,
      sms_notifications: true,
      custom_branding: true,
      multi_therapist: true,
      api_access: true
    },
    features: [
      'עסקים ללא הגבלה',
      'עד 1000 תורים בחודש',
      'מטפלים מרובים',
      'אנליטיקה מתקדמת',
      'API גישה',
      'תמיכה VIP'
    ]
  }
};

// ===================================
// 🔍 פונקציות קבלת נתוני מנוי
// ===================================

/**
 * קבלת פרטי מנוי של משתמש מהמסד
 */
export async function getUserSubscription(userId: string): Promise<UserSubscription> {
  const supabase = await getSupabaseClient('server');
  
  try {
    // חיפוש במטבלת subscribers
    const { data: subscriber, error } = await supabase
      .from('subscribers')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error && error.code !== 'PGRST116') {
      console.error('Error fetching subscription:', error);
    }

    // אם אין מנוי, החזר ברירת מחדל
    if (!subscriber) {
      return {
        id: '',
        user_id: userId,
        email: '',
        subscribed: false,
        subscription_tier: 'free',
        monthly_limit: 10,
        monthly_appointments_used: 0,
        billing_period_start: new Date().toISOString().slice(0, 10),
        billing_period_end: new Date(new Date().setMonth(new Date().getMonth() + 1)).toISOString().slice(0, 10)
      };
    }

    return subscriber;
  } catch (error) {
    console.error('Error in getUserSubscription:', error);
    // ברירת מחדל במקרה של שגיאה
    return {
      id: '',
      user_id: userId,
      email: '',
      subscribed: false,
      subscription_tier: 'free',
      monthly_limit: 10,
      monthly_appointments_used: 0
    };
  }
}

/**
 * קבלת תוכנית מנוי לפי tier
 */
export function getSubscriptionPlan(tier: 'free' | 'premium' | 'business'): SubscriptionPlan {
  return SUBSCRIPTION_PLANS[tier] || SUBSCRIPTION_PLANS.free;
}

/**
 * בדיקה האם משתמש הוא premium (כל מנוי שאינו חינם)
 */
export async function isPremiumUser(userId: string): Promise<boolean> {
  const subscription = await getUserSubscription(userId);
  return subscription.subscription_tier !== 'free' && subscription.subscribed;
}

/**
 * בדיקה האם משתמש יכול לגשת לתכונה מסוימת
 */
export async function hasFeatureAccess(
  userId: string, 
  feature: keyof SubscriptionLimits
): Promise<boolean> {
  const subscription = await getUserSubscription(userId);
  const plan = SUBSCRIPTION_PLANS[subscription.subscription_tier];
  
  return !!plan.limits[feature];
}

// ===================================
// 🔒 פונקציות בדיקת מגבלות
// ===================================

/**
 * בדיקת מגבלות משתמש לפי פעולה - הפונקציה המרכזית
 */
export async function checkUserLimit(
  userId: string, 
  action: 'create_business' | 'create_appointment' | 'send_sms'
): Promise<LimitCheckResult> {
  try {
    const subscription = await getUserSubscription(userId);
    const plan = SUBSCRIPTION_PLANS[subscription.subscription_tier];

    switch (action) {
      case 'create_business':
        return await checkBusinessLimit(userId, plan);
      
      case 'create_appointment':
        return await checkAppointmentLimit(subscription, plan);
      
      case 'send_sms':
        return await checkSMSLimit(plan);
      
      default:
        return { allowed: true };
    }
  } catch (error) {
    console.error('Error in checkUserLimit:', error);
    return { 
      allowed: false, 
      reason: 'שגיאה בבדיקת מגבלות. נסה שוב מאוחר יותר.',
      upgradeRequired: false
    };
  }
}

/**
 * בדיקת מגבלת עסקים
 */
async function checkBusinessLimit(userId: string, plan: SubscriptionPlan): Promise<LimitCheckResult> {
  if (plan.limits.businesses === 'unlimited') {
    return { allowed: true };
  }
  
  const businessCount = await getBusinessCount(userId);
  const maxBusinesses = plan.limits.businesses as number;
  const remaining = maxBusinesses - businessCount;
  
  if (businessCount >= maxBusinesses) {
    return { 
      allowed: false, 
      reason: `הגעת למגבלת העסקים (${maxBusinesses}). שדרג לתוכנית גבוהה יותר לעסקים נוספים.`,
      remainingCount: 0,
      upgradeRequired: true
    };
  }
  
  return { 
    allowed: true, 
    remainingCount: remaining 
  };
}

/**
 * בדיקת מגבלת תורים חודשית
 */
async function checkAppointmentLimit(subscription: UserSubscription, plan: SubscriptionPlan): Promise<LimitCheckResult> {
  if (plan.limits.appointments_per_month === 'unlimited') {
    return { allowed: true };
  }
  
  // בדיקה האם אנחנו בתקופת החיוב הנוכחת
  const now = new Date();
  const billingEnd = subscription.billing_period_end ? new Date(subscription.billing_period_end) : null;
  
  // אם עברנו את תקופת החיוב, איפוס השימוש
  if (billingEnd && now > billingEnd) {
    await resetMonthlyUsage(subscription.user_id);
    // החזר מנוי מעודכן
    const updatedSubscription = await getUserSubscription(subscription.user_id);
    subscription.monthly_appointments_used = updatedSubscription.monthly_appointments_used;
  }
  
  const appointmentCount = subscription.monthly_appointments_used || 0;
  const monthlyLimit = subscription.monthly_limit;
  const remaining = monthlyLimit - appointmentCount;
  
  if (appointmentCount >= monthlyLimit) {
    return { 
      allowed: false, 
      reason: `הגעת למגבלת התורים החודשית (${monthlyLimit}). שדרג לתוכנית גבוהה יותר לתורים נוספים.`,
      remainingCount: 0,
      upgradeRequired: true
    };
  }
  
  return { 
    allowed: true, 
    remainingCount: remaining 
  };
}

/**
 * בדיקת מגבלת SMS
 */
async function checkSMSLimit(plan: SubscriptionPlan): Promise<LimitCheckResult> {
  if (!plan.limits.sms_notifications) {
    return { 
      allowed: false, 
      reason: 'SMS התראות זמינות רק בתוכניות בתשלום. שדרג כדי לקבל התראות SMS אוטומטיות.',
      upgradeRequired: true
    };
  }
  return { allowed: true };
}

// ===================================
// 📊 פונקציות עדכון שימוש
// ===================================

/**
 * עדכון שימוש בתורים (להפעיל אחרי יצירת תור)
 */
export async function incrementAppointmentUsage(userId: string): Promise<void> {
  const supabase = await getSupabaseClient('server');
  
  try {
    // עדכון בטבלת subscribers
    const { error } = await supabase
      .from('subscribers')
      .update({ 
        monthly_appointments_used: supabase.rpc('increment_appointment_usage', { user_id_param: userId })
      })
      .eq('user_id', userId);

    if (error) {
      console.error('Error incrementing appointment usage:', error);
      
      // אם RPC לא עובד, נסה עדכון ישיר
      const subscription = await getUserSubscription(userId);
      await supabase
        .from('subscribers')
        .update({ 
          monthly_appointments_used: (subscription.monthly_appointments_used || 0) + 1,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', userId);
    }
  } catch (error) {
    console.error('Error in incrementAppointmentUsage:', error);
  }
}

/**
 * איפוס שימוש חודשי (לקרון job או כשעובר חודש)
 */
export async function resetMonthlyUsage(userId?: string): Promise<void> {
  const supabase = await getSupabaseClient('server');
  
  try {
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    const currentPeriodStart = new Date(now.getFullYear(), now.getMonth(), 1);
    
    let query = supabase
      .from('subscribers')
      .update({ 
        monthly_appointments_used: 0,
        billing_period_start: currentPeriodStart.toISOString().slice(0, 10),
        billing_period_end: nextMonth.toISOString().slice(0, 10),
        updated_at: new Date().toISOString()
      });

    if (userId) {
      // איפוס למשתמש ספציפי
      query = query.eq('user_id', userId);
    } else {
      // איפוס לכל המשתמשים שסיימו את התקופה החודשית
      query = query.lte('billing_period_end', now.toISOString().slice(0, 10));
    }

    const { error } = await query;

    if (error) {
      console.error('Error resetting monthly usage:', error);
    } else {
      console.log(`Monthly usage reset ${userId ? `for user ${userId}` : 'for all eligible users'}`);
    }
  } catch (error) {
    console.error('Error in resetMonthlyUsage:', error);
  }
}

// ===================================
// 💾 פונקציות ניהול מנויים
// ===================================

/**
 * יצירת או עדכון מנוי במסד הנתונים
 */
export async function upsertSubscriber(data: {
  userId: string;
  email: string;
  stripeCustomerId?: string;
  subscribed: boolean;
  subscriptionTier: 'free' | 'premium' | 'business';
  subscriptionEnd?: string;
  monthlyLimit?: number;
}): Promise<void> {
  const supabase = await getSupabaseClient('server');
  
  try {
    const plan = SUBSCRIPTION_PLANS[data.subscriptionTier];
    const monthlyLimit = data.monthlyLimit || 
      (typeof plan.limits.appointments_per_month === 'number' ? plan.limits.appointments_per_month : 10);
    
    // עדכון/יצירה בטבלת subscribers
    const { error: subscriberError } = await supabase
      .from('subscribers')
      .upsert({
        user_id: data.userId,
        email: data.email,
        stripe_customer_id: data.stripeCustomerId,
        subscribed: data.subscribed,
        subscription_tier: data.subscriptionTier,
        subscription_end: data.subscriptionEnd,
        monthly_limit: monthlyLimit,
        updated_at: new Date().toISOString()
      }, { 
        onConflict: 'user_id' 
      });

    if (subscriberError) {
      console.error('Error upserting subscriber:', subscriberError);
      throw subscriberError;
    }

    // עדכון גם בטבלת users
    const { error: userError } = await supabase
      .from('users')
      .update({ subscription_tier: data.subscriptionTier })
      .eq('id', data.userId);

    if (userError) {
      console.error('Error updating user subscription tier:', userError);
    }

    console.log(`Subscription updated for user ${data.userId}: ${data.subscriptionTier}`);
  } catch (error) {
    console.error('Error in upsertSubscriber:', error);
    throw error;
  }
}

/**
 * ביטול מנוי - החזרה לחינם
 */
export async function cancelSubscription(userId: string): Promise<void> {
  await upsertSubscriber({
    userId,
    email: '', // יועדכן בפועל מהמסד
    subscribed: false,
    subscriptionTier: 'free',
    monthlyLimit: 10
  });
}

// ===================================
// 🔧 פונקציות עזר
// ===================================

/**
 * ספירת עסקים פעילים של משתמש
 */
async function getBusinessCount(userId: string): Promise<number> {
  const supabase = await getSupabaseClient('server');
  
  try {
    const { count, error } = await supabase
      .from('businesses')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('is_active', true);

    if (error) {
      console.error('Error counting businesses:', error);
      return 0;
    }

    return count || 0;
  } catch (error) {
    console.error('Error in getBusinessCount:', error);
    return 0;
  }
}

/**
 * ספירת תורים במחצית הנוכחת
 */
export async function getMonthlyAppointmentCount(userId: string): Promise<number> {
  const subscription = await getUserSubscription(userId);
  return subscription.monthly_appointments_used || 0;
}

/**
 * קבלת סטטיסטיקות שימוש
 */
export async function getUsageStats(userId: string): Promise<{
  businessCount: number;
  monthlyAppointments: number;
  monthlyLimit: number;
  usagePercentage: number;
  tier: string;
}> {
  const [subscription, businessCount] = await Promise.all([
    getUserSubscription(userId),
    getBusinessCount(userId)
  ]);

  const usagePercentage = subscription.monthly_limit > 0 
    ? (subscription.monthly_appointments_used / subscription.monthly_limit) * 100 
    : 0;

  return {
    businessCount,
    monthlyAppointments: subscription.monthly_appointments_used,
    monthlyLimit: subscription.monthly_limit,
    usagePercentage: Math.round(usagePercentage),
    tier: subscription.subscription_tier
  };
}

/**
 * בדיקה האם המשתמש צריך להזהיר על מגבלה
 */
export async function shouldShowUsageWarning(userId: string, threshold: number = 80): Promise<{
  shouldShow: boolean;
  type: 'businesses' | 'appointments' | null;
  message?: string;
}> {
  const stats = await getUsageStats(userId);
  
  // בדיקת מגבלת עסקים
  const plan = SUBSCRIPTION_PLANS[stats.tier];
  if (plan.limits.businesses !== 'unlimited') {
    const businessLimit = plan.limits.businesses as number;
    const businessUsagePercent = (stats.businessCount / businessLimit) * 100;
    
    if (businessUsagePercent >= threshold) {
      return {
        shouldShow: true,
        type: 'businesses',
        message: `אתה משתמש ב-${stats.businessCount} מתוך ${businessLimit} עסקים`
      };
    }
  }
  
  // בדיקת מגבלת תורים
  if (stats.usagePercentage >= threshold) {
    return {
      shouldShow: true,
      type: 'appointments',
      message: `השתמשת ב-${stats.monthlyAppointments} מתוך ${stats.monthlyLimit} תורים החודש`
    };
  }
  
  return { shouldShow: false, type: null };
}

// ===================================
// 🎯 פונקציות אמצעים
// ===================================

/**
 * פונקציה לויידציה של מגבלות לפני פעולה
 */
export async function validateAndExecute<T>(
  userId: string,
  action: 'create_business' | 'create_appointment' | 'send_sms',
  executor: () => Promise<T>
): Promise<T> {
  const limitCheck = await checkUserLimit(userId, action);
  
  if (!limitCheck.allowed) {
    throw new Error(limitCheck.reason || 'הגעת למגבלה');
  }
  
  const result = await executor();
  
  // עדכון שימוש אחרי הפעולה
  if (action === 'create_appointment') {
    await incrementAppointmentUsage(userId);
  }
  
  return result;
}

/**
 * יצירת מידע על תוכנית המומלצת לשדרוג
 */
export function getRecommendedUpgrade(currentTier: 'free' | 'premium' | 'business'): SubscriptionPlan | null {
  switch (currentTier) {
    case 'free':
      return SUBSCRIPTION_PLANS.premium;
    case 'premium':
      return SUBSCRIPTION_PLANS.business;
    case 'business':
      return null; // כבר בתוכנית הגבוהה ביותר
    default:
      return SUBSCRIPTION_PLANS.premium;
  }
}

// ===================================
// 📱 פונקציות לRPC במסד הנתונים
// ===================================

/**
 * יצירת פונקציה RPC במסד הנתונים לעדכון שימוש (להרצה פעם אחת)
 */
export const createIncrementUsageFunction = `
CREATE OR REPLACE FUNCTION increment_appointment_usage(user_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
    new_count INTEGER;
BEGIN
    UPDATE subscribers 
    SET monthly_appointments_used = monthly_appointments_used + 1,
        updated_at = NOW()
    WHERE user_id = user_id_param
    RETURNING monthly_appointments_used INTO new_count;
    
    RETURN COALESCE(new_count, 0);
END;
$$ LANGUAGE plpgsql;
`;

/**
 * פונקציה לאיפוס שימוש חודשי בDB
 */
export const createResetUsageFunction = `
CREATE OR REPLACE FUNCTION reset_monthly_usage()
RETURNS INTEGER AS $$
DECLARE
    reset_count INTEGER;
BEGIN
    UPDATE subscribers 
    SET monthly_appointments_used = 0,
        billing_period_start = date_trunc('month', NOW()),
        billing_period_end = date_trunc('month', NOW()) + INTERVAL '1 month',
        updated_at = NOW()
    WHERE billing_period_end <= NOW()::date;
    
    GET DIAGNOSTICS reset_count = ROW_COUNT;
    RETURN reset_count;
END;
$$ LANGUAGE plpgsql;
`;

// ===================================
// 📤 Export all functions
// ===================================
export default {
  // Core functions
  getUserSubscription,
  checkUserLimit,
  incrementAppointmentUsage,
  resetMonthlyUsage,
  upsertSubscriber,
  
  // Helper functions
  isPremiumUser,
  hasFeatureAccess,
  getUsageStats,
  shouldShowUsageWarning,
  getRecommendedUpgrade,
  validateAndExecute,
  
  // Constants
  SUBSCRIPTION_PLANS
};